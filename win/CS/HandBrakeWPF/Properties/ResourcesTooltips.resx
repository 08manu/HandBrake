<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="FilterView_Deblock" xml:space="preserve">
    <value>The deblocking filter removes a common type of compression artifact.
If your source exhibits 'blockiness', this filter may help clean it up.</value>
  </data>
  <data name="FilterView_DecombDeinterlace" xml:space="preserve">
    <value>Choose decomb or deinterlace filter options.

The decomb filter selectively deinterlaces frames that appear to be interlaced.
This will preserve quality in frames that are not interlaced.

The classic deinterlace filter is applied to all frames.
Frames that are not interlaced will suffer some quality degradation.</value>
  </data>
  <data name="FilterView_Denoise" xml:space="preserve">
    <value>Denoise filtering reduces or removes the appearance of noise and grain.
Film grain and other types of high frequency noise are difficult to compress.
Using this filter on such sources can result in smaller file sizes.</value>
  </data>
  <data name="FilterView_Detelecine" xml:space="preserve">
    <value>This filter removes 'combing' artifacts that are the result of telecining.

Telecining is a process that adjusts film framerates that are 24fps to NTSC video frame rates which are 30fps.</value>
  </data>
  <data name="FilterView_Grayscale" xml:space="preserve">
    <value>If enabled, filter colour components out of video.</value>
  </data>
  <data name="MainView_Destination" xml:space="preserve">
    <value>This is the location and filename where your encoded file will be saved.</value>
  </data>
  <data name="MainView_IpodAtom" xml:space="preserve">
    <value>Add iPod Atom needed by some older iPods.</value>
  </data>
  <data name="MainView_Mux" xml:space="preserve">
    <value>Format to mux encoded tracks to.</value>
  </data>
  <data name="MainView_Optimise" xml:space="preserve">
    <value>Optimise the layout of the MP4 file for progressive download.
This allows a player to initiate playback before downloading the entire file.</value>
  </data>
  <data name="MainView_Range" xml:space="preserve">
    <value>Choose a start and end point of the source title to encode. This can be in chapters, seconds or frames.</value>
  </data>
  <data name="MainView_Title" xml:space="preserve">
    <value>Set the title to encode.
By default, HandBrake will try and select the main title, or the longest if one isn't found.</value>
  </data>
  <data name="PictureSettingsView_Anamorphic" xml:space="preserve">
    <value>None   - Force pixel aspect ratio to 1:1.
Loose  - Align dimensions to chosen 'Alignment' value
               and pick pixel aspect ratio that preserves the
               original display aspect ratio
Strict - Keep original source dimensions and pixel aspect ratio</value>
  </data>
  <data name="PictureSettingsView_Modulus" xml:space="preserve">
    <value>Align storage dimensions to multiples of this value.

This setting is only necessary for compatibility with some devices.
You should use 2 unless you experience compatibility issues.</value>
  </data>
  <data name="PictureSettingsView_PAR" xml:space="preserve">
    <value>Pixel aspect defines the shape of the pixels.
A 1:1 ratio defines a square pixel.  Other values define rectangular shapes.
Players will scale the image in order to achieve the specified aspect.</value>
  </data>
  <data name="QueueView_DeleteJob" xml:space="preserve">
    <value>Delete the job from the queue.</value>
  </data>
  <data name="QueueView_ResetJobStatus" xml:space="preserve">
    <value>Reset job status to Waiting.</value>
  </data>
  <data name="QueueView_SendJobBack" xml:space="preserve">
    <value>Send the job back to the main window for editing.</value>
  </data>
</root>